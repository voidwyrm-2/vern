import std/[
  os,
  strutils
]

import
  general,
  lexer,
  parser,
  interpreter,
  builtins

import pkg/[
  nargparse,
  Noise
]


const replHistoryFile = "vern_history"


proc displayStack(stack: seq[Value]) =
  var col = 28

  for val in stack:
    echo "\e", "[38;5;", col, "m", val

    col += 4

    if col in {51..62}:
      col = 64
    elif col > 231:
      col = 28

  stdout.write "\e[0m"

proc repl() =
  if not replHistoryFile.fileExists():
    replHistoryFile.writeFile("")

  var hf: File = nil

  if not open(hf, replHistoryFile, fmReadWriteExisting):
    echo "Cannot open ", replHistoryFile
    quit 1

  defer:
    hf.close()

  var noise = Noise.init()

  for line in hf.readAll().split("\n"):
    noise.historyAdd(line)

  hf.setFilePos(hf.getFileSize(), fspSet)
  
  echo "Vern ", langVersion, " (end with ctrl-c, type 'help' for a list of commands)"

  setControlCHook(proc() {.noconv.} = quit 0)

  let
    basePrompt = "   "
    i = newInterpreter(builtins.builtins)
  
  noise.setPrompt(basePrompt)
  
  while true:
    if not noise.readLine():
      break
  
    let line = noise.getLine()

    case line
    of "help":
      echo """

help - Show this message
clear - Clear the stack
exit - Exit the REPL
"""
      continue
    of "clear":
      i.state.clearStack()
      continue
    of "exit":
      break
  
    try:
      if line.len > 0:
        let
          l = newLexer("repl", newStringBuffer(line))
          p = newParser(l.lex())
        
        i.exec(p.parse())
        
        displayStack(i.state.stack)
    except VernError as e:
      echo e
  
    hf.writeLine(line)
    noise.historyAdd(line)

proc main() =
  let
    argp = newArgparser("vern")
    fHelp = argp.flag("h", "help", help="Displays the usage.")
    fVersion = argp.flag("v", "version", help="Displays the version.")
    fRepl = argp.flag("repl", help="Begin the REPL.")
    fTokens = argp.flag("t", "tokens", help="Show the tokens generated by the lexer.")
    fStack = argp.flag("s", "stack", help="Show the stack at the end of execution.")
    fNodes = argp.flag("n", "nodes", help="Show the nodes generated by the parser.")
    fBindings = argp.flag("b", "bindings", help="Show the bindings at the end of execution")

  var args: seq[string]
  try:
    args = argp.parse(commandLineParams())
  except ArgparseError as e:
    echo e.msg
    echo argp
    quit 1

  if fHelp.exists:
    echo argp
    quit 0

  if fVersion.exists:
    echo "Vern version ", langVersion
    quit 0

  if fRepl.exists:
    repl()
    quit 0

  if args.len() == 0:
    echo "No input files given"
    quit 1

  let filepath = args[0]

  var f: File
  if not open(f, filepath):
    echo "File '", filepath, "' could not be opened"
    quit 1

  let l = newLexer(filepath, newFileBuffer(f))

  let tokens =
    try:
      l.lex()
    except VernError as e:
      echo e
      quit 1
    finally:
      f.close()

  if fTokens.exists:
    for tok in tokens:
      echo tok

    if fNodes.exists:
      echo ""

  let p = newParser(tokens)

  let nodes =
    try:
      p.parse()
    except VernError as e:
      echo e
      quit 1

  if fNodes.exists:
    for node in nodes:
      echo node

  let i = newInterpreter(builtins.builtins)

  try:
    i.exec(nodes)
  except VernError as e:
    echo e
    quit 1

  if fBindings.exists:
    for (k, v) in i.state.bindings.pairs:
      echo k, " <- ", v

    if fStack.exists:
      echo ""


  if fStack.exists:
    displayStack(i.state.stack)


when isMainModule:
  main()
