import std/[
  os,
  strutils,
  sequtils,
  strformat,
  random
]

import
  general,
  lexer,
  parser,
  interpreter,
  builtins,
  preprocessing

import pkg/[
  nargparse,
  Noise
]

const
  replFilename = "repl"
  replHistoryFile = "vern_history"

  shortcutHelp = staticRead("data/unicode_shortcuts.map")
    .strip()
    .split("\n")
    .mapIt((
      let entry = it.split(":");
      var col = 21;
      let keys = entry[0]
        .split(",")
        .mapIt(it.strip())
        .mapIt((
          col += 6;
          "\e[38;5;" & $col & "m" &
          (if it.len == 1:
            fmt"\{it}"
          else:
            fmt"\.{it}\") &
            "\e[0m"
        ));
      fmt"""{keys.join(", ")} - {"\e[38;5;207m" & entry[1].strip() & "\e[0m"}"""
    ))
    .join("\n")

proc repl() =
  if not replHistoryFile.fileExists():
    replHistoryFile.writeFile("")

  var hf: File = nil

  if not open(hf, replHistoryFile, fmReadWriteExisting):
    echo "Cannot open ", replHistoryFile
    quit 1

  defer:
    hf.close()

  var noise = Noise.init()

  for line in hf.readAll().split("\n"):
    noise.historyAdd(line)

  hf.setFilePos(hf.getFileSize(), fspSet)
  
  echo "Vern ", langVersion, " (end with ctrl-c, type 'help' for a list of commands)"

  setControlCHook(proc() {.noconv.} = quit 0)

  let
    basePrompt = "   "
    i = newInterpreter(builtins.builtins.copy())
  
  noise.setPrompt(basePrompt)

  #var stateBackup: State 

  while true:
    if not noise.readLine():
      break
  
    let
      line = noise.getLine()
      parts = line.split(' ')

    hf.writeLine(line)
    noise.historyAdd(line)

    case line
    of "help":
      echo """

help - Show this message
shortcuts - List the glyph shortcuts
clear - Clear the stack
bindings - Show the current bindings.
unbind - Unbinds the specified binding
exit - Exit the REPL
"""
      continue
    of "shortcuts":
      echo "\n\e[38;5;27m\\'\e[0m: \e[38;5;207msuperscript\e[0m"
      echo "\e[38;5;27m\\,\e[0m: \e[38;5;207msubscript\e[0m"
      echo "\n", shortcutHelp, "\n"
      continue
    of "clear":
      i.state.clearStack()
      continue
    of "bindings":
      displayBindings(i.state.bindings)
      continue
    of "exit":
      break
    else:
      case parts[0]
      of "unbind":
        let args = parts[1..^1]

        if args.len != 1:
          echo "'unbind' needs a single argument"
          continue

        if i.state.unset(args[0]).isSome():
          echo fmt"Removed binding '{args[0]}'"
        else:
          echo fmt"Binding '{args[0]}' does not exist"

        continue

    let (str, collapses) =
      try:
        collapseEscapes(replFilename, line)
      except VernError as e:
        echo e
        continue

    if collapses > 0:
      echo "Formatted to: ", str

    #if line.len > 0:
    #  stateBackup = i.state.copy()
    
    try:
      if line.len > 0:
        let
          l = newLexer(replFilename, newStringBuffer(str))
          p = newParser(l.lex())
        
        i.exec(p.parse())
        
        displayStack(i.state.stack)
    except VernError as e:
      echo e
      #if stateBackup != nil:
      #  i.state = stateBackup

proc main() =
  randomize()

  let
    argp = newArgparser("vern")
    fHelp = argp.flag("h", "help", help="Displays the usage.")
    fVersion = argp.flag("v", "version", help="Displays the version.")
    fRepl = argp.flag("repl", help="Begin the REPL.")
    fTokens = argp.flag("t", "tokens", help="Show the tokens generated by the lexer.")
    fStack = argp.flag("s", "stack", help="Show the stack at the end of execution.")
    fNodes = argp.flag("n", "nodes", help="Show the nodes generated by the parser.")
    fBindings = argp.flag("b", "bindings", help="Show the bindings at the end of execution.")
    fClear = argp.flag("c", "clear", help="Clear the local history file.")

  var args: seq[string]
  try:
    args = argp.parse(commandLineParams())
  except ArgparseError as e:
    echo e.msg
    echo argp
    quit 1

  if fHelp.exists:
    echo argp
    quit 0

  if fVersion.exists:
    echo "Vern version ", langVersion
    quit 0

  if fClear.exists and replHistoryFile.fileExists():
    replHistoryFile.writeFile("")

  if fRepl.exists:
    repl()
    quit 0

  if args.len() == 0:
    echo "No input files given"
    quit 1

  let filepath = args[0]

  try:
    collapseEscapes(filepath)
  except VernError as e:
    echo e
    quit 1

  var f: File
  if not open(f, filepath):
    echo "File '", filepath, "' could not be opened"
    quit 1

  let l = newLexer(filepath, newFileBuffer(f))

  let tokens =
    try:
      l.lex()
    except VernError as e:
      echo e
      quit 1
    finally:
      f.close()

  if fTokens.exists:
    for tok in tokens:
      echo tok

    if fNodes.exists:
      echo ""

  let p = newParser(tokens)

  let nodes =
    try:
      p.parse()
    except VernError as e:
      echo e
      quit 1

  if fNodes.exists:
    for node in nodes:
      echo node

  let i = newInterpreter(builtins.builtins.copy())

  try:
    i.exec(nodes)
  except VernError as e:
    echo e
    quit 1

  if fBindings.exists:
    displayBindings(i.state.bindings)

    if fStack.exists:
      echo ""


  if fStack.exists:
    displayStack(i.state.stack)


when isMainModule:
  main()
